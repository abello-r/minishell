En orden de prioridad los errores que quedan pendiente y a su lado pruebas que hacer para comprobar que esten OK:

3- En el CD, comprobar que la ruta a la que quiere acceder el cd, exista, en caso contrario deberia mostrar un error [TODO]
Pruebas (En orden de importancia):
	* mkdir test ; cd test ; mkdir test2 ; cd test2 ; rm -rf ../../test ; cd .. 
	* cd rutaInventada
	NOTA:
	(El uso de ; no es obligatorio,
	pero es para poder mostrar la serie de comandos en una linea... 
	este caso da segfault y deberia dar un mensaje de error 
	[cd: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory])

6- En el EXIT debería retornar el valor del proceso que ha salido [TODO]
	0 - Éxito: Indica que el comando o el script se ejecutó correctamente sin errores.
	1 - Error genérico: Se usa para indicar que ocurrió un error genérico. No especifica un tipo de error en particular.
	2 - Uso incorrecto del comando: Indica que el comando fue llamado con argumentos incorrectos.
	126 - No se puede ejecutar: El comando fue encontrado, pero no se puede ejecutar. Esto podría deberse a permisos insuficientes.
	127 - Comando no encontrado: El comando no fue encontrado. Es común cuando se intenta ejecutar un programa o script que no existe en el sistema.
	128 - Error en la salida del shell: Un error en la salida del shell. Indica que el shell fue terminado de manera incorrecta.
	128 + N - Terminación por señal: Indica que el proceso fue terminado por una señal (signal). Aquí, N es el número de la señal que terminó el proceso. 
	Por ejemplo, 137 indica que el proceso fue terminado por la señal 9 (SIGKILL).

7- Comprobar LEAKS [TODO]

COSAS QUE HAY QUE HACER
3) Limpiar codigo
5) Tener en cuenta que una PIPE o redirecc. puede ir pegada al ARG (parseo)

echo hello world
echo "hello world"
echo 'hello world'
echo hello'world' - KO
echo hello""world - KO
echo ''
echo "$PWD" - KO
echo '$PWD'
echo "aspas ->'" - KO
echo "aspas -> ' " - KO
echo 'aspas ->"' - KO
echo 'aspas -> " ' - KO
echo "> >> < * ? [ ] | ; [ ] || && ( ) & # $ \ <<"
echo '> >> < * ? [ ] | ; [ ] || && ( ) & # $ \ <<'
echo "exit_code ->$? user ->$USER home -> $HOME" - KO
echo 'exit_code ->$? user ->$USER home -> $HOME'
echo "$"
echo '$'
echo $ - KO
echo $? - KO
echo $?HELLO -KO
pwd
pwd oi

export hello
export HELLO=123
export A-
export HELLO=123 A
export HELLO="123 A-" - KO
export hello world
export HELLO-=123
export =
export 123
unset
unset HELLO
unset HELLO1 HELLO2
unset HOME
unset PATH
unset SHELL

cd $PWD
cd $PWD hi 
cd 123123
cd .. hi

# Prints without a new line
echo -n hello

# update env variable value
export HELLO=123
export HELLO="beautiful world"

# keep track of OLDPWD
cd obj
echo $PWD $OLDPWD

# invalid command, followed by empty input, should keep the exit code
doesntexist

echo $?

#invalid command, followed by empty variable, should clear the exit code
doesntexist
$EMPTY
echo $?

# Check if there isn't a zombie process called `cat`
echo "hi" | cat | cat | cat | cat | cat | cat | cat
ps -a

# Should skip the empty argument, and print hello after spaces
echo - "" "  " hello

# Neither of these unsets should break the shell, and you should still be able to call `/bin/ls`
unset USER
unset PATH
unset PWD
/bin/ls

# This should not change the current directory
cd .. hi

# Empty `cd` moves to home
cd

CTRL+C
CTRL+D
CTRL+\
CTRL+C, CTRL+C, CTRL+C, exit
CTRL+C, CTRL+C, CTRL+C, Ctrl+D

cat | ls # testar dando depois:
#- Enter
#- Ctrl+D
#- Ctrl+\
#- Ctrl+C

grep oi | ls # testar dando depois:
#- Enter + Ctrl+D
#- Ctrl+D
#- "oi" + Enter + Ctrl+D
#- Ctrl+\
#- Ctrl+C
#- "oi" + Enter + Ctrl+\

./test_files/loop.out # finalizar com:
#- Ctrl+C
#- Ctrl+\  -> workspaces: ^\Quit\n
#- Ctrl+D  -> não faz nada

./test_files/loop.out | ls
# finalizar com:
#- Ctrl+C
#- Ctrl+\
#- Ctrl+D

ls | ./test_files/loop.out
# finalizar com:
#- Ctrl+C
#- Ctrl+\
#- Ctrl+D

hello + Ctrl+C
# Check that the new line is empty
